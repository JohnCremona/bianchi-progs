// FILE qideal.h
// should only be included if ideal-methods is selected, i.e. MAX_CLASSNUM>1
#ifndef __QIDEAL_H__
#define __QIDEAL_H__

#include "quads.h"

class Qideal  {
protected:
  long a,b,c;   // the Z-basis in standard form  I=c[a,b+w]
  long iclass;  // 0 if principal, 1 if not (since h<=2), -1 if undetermined
  Quad g0,g1;   // if iclass!=-1 then I=<g0,g1>, g0 non-zero of minl norm,
                // thus  iclass=0 iff I=<g0>, when g1 is undefined
                // currently g1=0 if I princ a priori, o/w as found by fill()
  long index;   // Index (from 1) of this ideal in the standard
                // sorting of ideals of the same norm, or -1 if not known

public:
//constructors
  Qideal();                          // base initialization for class `Qideal'
  Qideal(const Qideal& );            // the copy constructor
  Qideal(const long&, const long&, const long&); // construct given Z-basis abc
  Qideal(const long&);               // princ ideal gen by long
  Qideal(const Quad&);               // princ ideal gen by Quad
  Qideal(const vector<Quad>&);       // ideal generated by list of Quads */
  Qideal(const vector<long>&, const vector<long>&);  // ideal from Z-gens */
  Qideal(const string& s);           // ideal from label N.i

  // member access
  long get_a() const {return a;}
  long get_b() const {return b;}
  long content() const {return c;}
  long smallest_integer() const {return a*c;}
  Quad gen() const {return g0;}
  Quad zgen(int i) const {return (i? Quad(b*c,c): Quad(a*c));} // Z-module gens
  vector<Quad> gens() const {return {g0, g1};}
  vector<long> get_rv() const {return {a*c, b*c};} // real parts of Z-module gens
  vector<long> get_iv() const {return {  0, c};}   // imag parts of Z-module gens

  void set_index(int ind=0); // if 0 (default) computes the correct index
  long get_index()
  {
    if (index<1) set_index();
    return index;
  }
//
//operators
//
  int operator== (const Qideal& f) const {return (a==f.a)&&(b==f.b)&&(c==f.c);}
  int operator!= (const Qideal& f) const {return (a!=f.a)||(b!=f.b)||(c!=f.c);}
//
  Qideal operator+(const long&) const;
  Qideal operator+(const Quad&) const;
  Qideal operator+(const Qideal&) const;
  friend Qideal operator+(const long&, const Qideal&);
  friend Qideal operator+(const Quad&, const Qideal&);
  void operator+=(const long&);
  void operator+=(const Quad&);
  void operator+=(const Qideal&);
//
  Qideal operator*(const long&) const;
  Qideal operator*(const Quad&) const;
  Qideal operator*(const Qideal&) const;
  friend Qideal operator*(const long&, const Qideal&);
  friend Qideal operator*(const Quad&, const Qideal&);
  void operator*=(const long&);
  void operator*=(const Quad&);
  void operator*=(const Qideal&);

  Qideal ideal_prod_coeffs(const Qideal&, Quad&, Quad&, Quad&, Quad&) const;
  Qideal princprod(const Qideal&q, Quad&alpha, Quad&beta) const;

//
  Qideal operator/(const long&) const;
  Qideal operator/(const Quad&) const;
  Qideal operator/(const Qideal&) const;
  friend Qideal operator/(const long&, const Qideal&);
  friend Qideal operator/(const Quad&, const Qideal&);
  void operator/=(const long&);
  void operator/=(const Quad&);
  void operator/=(const Qideal&);
//
//functions defined in qideal.cc unless inline
  int is_principal();         // fills iclass if necessary
  int is_equivalent(Qideal& I) {return (I.conj()*(*this)).is_principal();}
  int is_anti_equivalent(Qideal& I) {return (I*(*this)).is_principal();}
  int contains(const long& n) const {return n%(a*c)==0;}
  int contains(const Quad& alpha) const;
  int contains(const Qideal& I) const  {return ((I.c)%c==0) && contains(I.zgen(0)) && contains(I.zgen(1));};
  int divides(const long& n) const {return contains(n);}
  int divides(const Quad& alpha) const  {return contains(alpha);}
  int divides(const Qideal& I) const  {return contains(I);}

  double dnorm() const { double ans=a; ans*=c; ans*=c; return ans; }
  long norm() const
    { double dn=dnorm();
      if (dn>MAXLONG) cerr << "Error: Qideal::norm overflow!" << endl;
      return (long)dn;
    }

  Qideal conj() const;            // returns the conjugate ideal

  friend int comax(const Qideal&, const Qideal&, Quad&, Quad&);
  // returns 1 iff Qideals are comax, when returns one Quad from each, sum = 1

// i/o
  friend ostream& operator<<(ostream& s, const Qideal& x);
  friend istream& operator>>(istream& s, Qideal& x);

  friend class Quadprime;

private:
  int ok() const;                 // checks that [a,b+w] *is* an ideal
  void fill();                    // determines iclass, g0, g1
  void abc_from_HNF(vector<long>&);
  Quad princprod_coeff_alpha(vector<long>&z) const;   // for use only in...
  Quad princprod_coeff_beta(vector<long>&z) const;    // ... ideal_prod_coeffs
  Quad elt_spanned_by(const long&, const long&) const;
};

Qideal Qideal_from_norm_index(long N, int i); // i'th ideal of norm N

char* to_string(const Qideal& a);  // outputs to a (new) string

long val(const Qideal& factor, const Qideal& dividend);

// These three functions return lists which are not sorted in the standard way
vector<Qideal> primitive_ideals_with_norm(long N, int both_conj=1);
vector<Qideal> ideals_with_norm(long N, int both_conj=1);
vector<Qideal> ideals_with_bounded_norm(long maxnorm, int both_conj=1);

string ideal_label(Qideal& I);  // returns label of ideal I

// Class to hold sorted lists of ideals of given norm
class Qideal_lists {
  static map<long, vector<Qideal>> N_to_Ilist;
public:
  static vector<Qideal> ideals_with_norm(long N);
  static vector<Qideal> sorted_ideals_with_bounded_norm(long maxnorm);
};

#endif

// END OF FILE qideal.h
