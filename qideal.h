// FILE qideal.h
#ifndef __QIDEAL_H__
#define __QIDEAL_H__

#include "quads.h"

class Factorization;

class Qideal  {
protected:
  QUINT a,b,c;   // HNF Z-basis: I=c[a,b+w]
  QUINT ac;      // ac = a*c = smallest integer
  QUINT nm;      // nm = a*c*c = norm
  long iclass;  // 0 if principal, 1 if not, -1 if undetermined
  Quad g0,g1;   // Reduced Z-basis (if iclass!=-1):
                // I=<g0,g1>, g0 non-zero of minimal norm,
                // and iclass=0 iff I=<g0> is principal
  long index;   // Index (from 1) of this ideal in the standard
                // sorting of ideals of the same norm, or -1 if not known
  Factorization *F; // pointer to the ideal's factorization (only set when needed)
  vector<Quad> the_residues;
  void make_residues();

public:
//constructors
  Qideal();                          // base initialization for class `Qideal'
  Qideal(const Qideal& );            // the copy constructor
  Qideal(const QUINT&, const QUINT&, const QUINT&); // construct given Z-basis abc
  explicit Qideal(const QUINT&);               // princ ideal gen by integer
  explicit Qideal(const Quad&);               // princ ideal gen by Quad
  explicit Qideal(const vector<Quad>&);       // ideal generated by list of Quads */
  Qideal(const vector<QUINT>&, const vector<QUINT>&);  // ideal from Z-gens */
  explicit Qideal(const string& s);           // ideal from label N.i
  Qideal& operator= (const Qideal& I)
  { a=I.a;
    b=I.b;
    c=I.c;
    ac=I.ac;
    nm=I.nm;
    iclass=I.iclass;
    g0=I.g0;
    g1=I.g1;
    index=I.index;
    F = 0;  // the reason why we cannot just use the default copy
    return *this;
  }

  // destructor // needs to free up F
  ~Qideal();

  // member access
  QUINT get_a() const {return a;}
  QUINT get_b() const {return b;}
  QUINT content() const {return c;}
  QUINT smallest_integer() const {return ac;}
  QUINT norm() const {return nm;}
  Quad zgen(int i) const {return (i? Quad(b*c,c): Quad(ac));} // HNF Z-module gens
  Quad gen();          // smallest element, so a generator iff principal
  vector<Quad> gens(); // reduced Z-module ggens
  vector<QUINT> get_rv() const {return {ac, b*c};} // real parts of Z-module gens
  vector<QUINT> get_iv() const {return { ZERO, c};}   // imag parts of Z-module gens

  void set_index(int ind=0); // if 0 (default) computes the correct index
  long get_index()
  {
    if (index<1) set_index();
    return index;
  }

  Factorization factorization(); // sets F if necessary then returns F

  //
  //operators
  //
  int operator== (const Qideal& f) const {return (a==f.a)&&(b==f.b)&&(c==f.c);}
  int operator!= (const Qideal& f) const {return (a!=f.a)||(b!=f.b)||(c!=f.c);}
//
  Qideal operator+(const QUINT&) const;
  Qideal operator+(const Quad&) const;
  Qideal operator+(const Qideal&) const;
  friend Qideal operator+(const QUINT&, const Qideal&);
  friend Qideal operator+(const Quad&, const Qideal&);
  void operator+=(const QUINT&);
  void operator+=(const Quad&);
  void operator+=(const Qideal&);
//
  Qideal operator*(const QUINT&) const;
  Qideal operator*(const Quad&) const;
  Qideal operator*(Qideal&) const;
  friend Qideal operator*(const QUINT&, const Qideal&);
  friend Qideal operator*(const Quad&, const Qideal&);
  void operator*=(const QUINT&);
  void operator*=(const Quad&);
  void operator*=(Qideal&);

  Qideal intersection(const Qideal& I);
  Quad second_generator(const Quad& a); // with nonzero a in this, return b such that this=(a,b)

  // Assuming this*J is principal, sets g to a generator and returns a
  // 2x2 matrix of determinant g whose columns generate this and J,
  // the first column being (g0,g1)
  mat22 AB_matrix(Qideal&J, Quad&g);
  // as above with J = conj(this), g=norm(this)
  mat22 AB_matrix();
  // As above with (2,1)-entry in N
  mat22 AB_matrix_of_level(const Qideal&N, Quad&g);
  mat22 AB_matrix_of_level(const Qideal&J, const Qideal&N, Quad&g);

  // test if this ideal is coprime to another ideal or a Quad:
  int is_coprime_to(const Qideal& I) const
  {
    QUINT g = gcd(ac, I.ac);
    QUINT one(1);
    return (g==one? 1: gcd(g, c*I.c*(b-I.b))==one);
  }
  int is_coprime_to(const Quad& alpha) const
  {
    return is_coprime_to(Qideal(alpha));
  }

  // versions returning more data

  // return 1 iff this is coprime to I; if so, set r in this and s in I with r+s=1
  int is_coprime_to(Qideal& J, Quad& r, Quad& s);

  // return 1 iff this is coprime to alpha; if so, set inverse so an inverse of alpha modulo this
  int is_coprime_to(const Quad& alpha, Quad& inverse);

  // Return 1 iff this is coprime to (c,d); if so, set x,y so c*x+d*y =1
  // modulo this ideal.  If fix=1, ensure that y is coprime to this.
  int is_coprime_to(const Quad& c, const Quad& d, Quad& x, Quad& y, int fix=0);

  // return J = (c/d)*this coprime to N, or (if anti=1) J such that J*this=(c) and d=1
  // (implemented in primes.cc)
  Qideal equivalent_coprime_to(const Qideal& N, Quad& c, Quad& d, int anti=0);

  // return J such that J^2 is equivalent to this (or J^2*this is
  // principal if anti==1), or if no such J exists (i.e., if the ideal
  // class is not a square), return the zero ideal.  (implemented in
  // primes.cc)
  Qideal sqrt_class(int anti=0);

  // return J coprime to N such that J^2*this is principal; if no such
  // J exists (i.e., if the ideal class is not a square, return the
  // zero ideal.  (implemented in primes.cc)
  Qideal sqrt_coprime_to(const Qideal& N);
  //
  Qideal operator/(const QUINT&) const;
  Qideal operator/(const Quad&) const;
  Qideal operator/(const Qideal&) const;
  friend Qideal operator/(const QUINT&, const Qideal&);
  friend Qideal operator/(const Quad&, const Qideal&);
  void operator/=(const QUINT&);
  void operator/=(const Quad&);
  void operator/=(const Qideal&);

//functions defined in qideal.cc unless inline
  int is_zero() const {return c==0;}
  int is_principal();          // fills iclass if necessary
  int is_principal(Quad& g);   // same but puts generator into g
  int is_primitive() const {return c==ONE;}
  int is_square();
  int is_Galois_stable() const {return div(a, (2*b+Quad::t));}
  int is_prime();
  int is_prime_power();
  int is_equivalent(const Qideal& I);
  int is_anti_equivalent(Qideal& I);
  int contains(const QUINT& n) const  {return div(ac, n);}
  int contains(const Quad& alpha) const;
  int contains(const Qideal& I) const  {return div(c,I.c) && div(ac,I.ac) && contains(I.zgen(1));}

  vector<QUINT> zcoeffs(const Quad& alpha) const // for alpha in this, return Z-coeffs {x,y} w.r.t.Z-gens.
  {
    return {(alpha.r-b*alpha.i)/ac, alpha.i/c};
  }
  Quad zcombo(const QUINT& x, const QUINT& y) const
  {
    return Quad(x*ac+y*b*c, y*c);
  }
  int divides(const QUINT& n) const {return contains(n);}
  int divides(const Quad& alpha) const  {return contains(alpha);}
  int divides(const Qideal& I) const  {return contains(I);}

  Qideal divide_out(const Qideal& I); // largest factor of this coprime to I
  void make_primitive();              // divide out content
  Qideal primitive_part() const;      // largest primitive factor of this (=this/content)

  Qideal conj() const;            // returns the conjugate ideal

  Quad reduce(const Quad& alpha); // reduction of alpha modulo this ideal (not const; may fill())
  Quad resnum(long i); // the i'the residue mod this, in standard order (0'th is 0)
  long numres(const Quad& alpha) const; // the index of a residue mod this, in standard order (0'th is 0)
  // return a list of (reduced) residues modulo this ideal:
  vector<Quad> residues();
  // return a list of (reduced) invertible residues modulo this ideal, and a list of their inverses
  pair<vector<Quad>, vector<Quad>> invertible_residues();

// i/o
  friend string gens_string(Qideal& I); // not const as it calls I.fill()
  friend ostream& operator<<(ostream& s, const Qideal& x);
  friend istream& operator>>(istream& s, Qideal& x);

  friend class Quadprime;
  friend struct Qideal_comparison;

private:
  int ok() const;                 // checks that [a,b+w] *is* an ideal
  void fill();                    // determines iclass, g0, g1
  void abc_from_HNF(const vector<QUINT>&);
};

// return i if I is equivalent to the i'th ideal in Jlist, else -1
int find_ideal_class(Qideal I, const vector<Qideal>& Jlist);
// return i if I is equivalent mod squares to the i'th ideal in Jlist, else -1
int find_ideal_class_mod_squares(Qideal I, const vector<Qideal>& Jlist);

// An AB-matrix with given first column
mat22 AB_matrix(const Quad& a, const Quad& c);

Qideal Qideal_from_norm_index(QUINT N, int i); // i'th ideal of norm N

long val(const Qideal& factor, const Qideal& dividend);

// If a is in (c,d) return 1 and x,y such that a=c*x+d*y, else return 0
int express2gens(const Quad& a, const Quad& c, const Quad& d, Quad& x, Quad& y);

// These three functions return lists which are not sorted in the standard way
vector<Qideal> primitive_ideals_with_norm(QUINT N, int both_conj=1);
vector<Qideal> ideals_with_norm(QUINT N, int both_conj=1);
vector<Qideal> ideals_with_bounded_norm(QUINT maxnorm, int both_conj=1);

string ideal_label(Qideal& I); // returns label of ideal I
string gens_string(Qideal& I);  // returns string of gens, of the form (x) if principal or (x,y) ideal I

// Class to hold sorted lists of ideals of given norm
class Qideal_lists {
  static map<QUINT, vector<Qideal>> N_to_Ilist;
public:
  static vector<Qideal> ideals_with_norm(QUINT N, int both_conj=1);
  static vector<Qideal> ideals_with_bounded_norm(QUINT maxnorm, int both_conj=1);
};

// return 1 iff a is the square mod M of some r in reslist
int squaremod(const Quad& a, const Qideal& M, const vector<Quad>& reslist);
vector<int> makechitable(const Qideal& L, const vector<Quad>& reslist);

// function to sort ideals, first by norm then by index within norm

struct Qideal_comparison {
  bool operator()(const Qideal& I, const Qideal& J)
  {
    return (I.nm<J.nm) || ((I.nm==J.nm) && (I.index<J.index));
  }
};

extern Qideal_comparison Qideal_cmp;


#endif

// END OF FILE qideal.h
