// FILE qideal.h
// should only be included if ideal-methods is selected, i.e. MAX_CLASSNUM>1
#ifndef __QIDEAL_H__
#define __QIDEAL_H__

#include "quads.h"

class Factorization;

class Qideal  {
protected:
  long a,b,c;   // HNF Z-basis: I=c[a,b+w]
  long ac;      // ac = a*c = smallest integer
  long nm;      // nm = a*c*c = norm
  long iclass;  // 0 if principal, 1 if not, -1 if undetermined
  Quad g0,g1;   // Reduced Z-basis (if iclass!=-1):
                // I=<g0,g1>, g0 non-zero of minimal norm,
                // and iclass=0 iff I=<g0> is principal
  long index;   // Index (from 1) of this ideal in the standard
                // sorting of ideals of the same norm, or -1 if not known
  Factorization *F; // pointer to the ideal's factorization (only set when needed)

public:
//constructors
  Qideal();                          // base initialization for class `Qideal'
  Qideal(const Qideal& );            // the copy constructor
  Qideal(const long&, const long&, const long&); // construct given Z-basis abc
  Qideal(const long&);               // princ ideal gen by long
  Qideal(const Quad&);               // princ ideal gen by Quad
  Qideal(const vector<Quad>&);       // ideal generated by list of Quads */
  Qideal(const vector<long>&, const vector<long>&);  // ideal from Z-gens */
  Qideal(const string& s);           // ideal from label N.i
  void operator= (const Qideal& I)
  { a=I.a;
    b=I.b;
    c=I.c;
    ac=I.ac;
    nm=I.nm;
    iclass=I.iclass;
    g0=I.g0;
    g1=I.g1;
    index=I.index;
    F = 0;  // the reason why we cannot just use the default copy
  }

  // destructor // needs to free up F
  ~Qideal();

  // member access
  long get_a() const {return a;}
  long get_b() const {return b;}
  long content() const {return c;}
  long smallest_integer() const {return ac;}
  long norm() const {return nm;}
  Quad zgen(int i) const {return (i? Quad(b*c,c): Quad(ac));} // HNF Z-module gens
  Quad gen() const {return g0;} // smallest element, so a generator iff principal
  vector<Quad> gens() const {return {g0, g1};} // reduced Z-module ggens
  vector<long> get_rv() const {return {ac, b*c};} // real parts of Z-module gens
  vector<long> get_iv() const {return { 0, c};}   // imag parts of Z-module gens

  void set_index(int ind=0); // if 0 (default) computes the correct index
  long get_index()
  {
    if (index<1) set_index();
    return index;
  }

  Factorization factorization(); // sets F if necessary then returns F

  //
  //operators
  //
  int operator== (const Qideal& f) const {return (a==f.a)&&(b==f.b)&&(c==f.c);}
  int operator!= (const Qideal& f) const {return (a!=f.a)||(b!=f.b)||(c!=f.c);}
//
  Qideal operator+(const long&) const;
  Qideal operator+(const Quad&) const;
  Qideal operator+(const Qideal&) const;
  friend Qideal operator+(const long&, const Qideal&);
  friend Qideal operator+(const Quad&, const Qideal&);
  void operator+=(const long&);
  void operator+=(const Quad&);
  void operator+=(const Qideal&);
//
  Qideal operator*(const long&) const;
  Qideal operator*(const Quad&) const;
  Qideal operator*(const Qideal&) const;
  friend Qideal operator*(const long&, const Qideal&);
  friend Qideal operator*(const Quad&, const Qideal&);
  void operator*=(const long&);
  void operator*=(const Quad&);
  void operator*=(const Qideal&);

  Qideal intersection(const Qideal& I);
  Quad second_generator(const Quad& a); // with nonzero a in this, return b such that this=(a,b)

  // Assuming this*J is principal, sets g to a generator and returns a
  // 2x2 matrix of determinant g whose columns generate this and J,
  // the first column being (g0,g1)
  mat22 AB_matrix(Qideal&J, Quad&g);
  // as above with J = conj(this), g=norm(this)
  mat22 AB_matrix();
  // As above with (2,1)-entry in N
  mat22 AB_matrix_of_level(const Qideal&N, Quad&g);

  // test if this ideal is coprime to another ideal or a Quad:
  int is_coprime_to(const Qideal& I) const
  {
    long g = gcd(ac, I.ac);
    return (g==1? 1: gcd(g, c*I.c*(b-I.b))==1);
  }
  int is_coprime_to(const Quad& alpha) const
  {
    return is_coprime_to(Qideal(alpha));
  }

  // versions returning more data

  // return 1 iff this is coprime to I; if so, set r in this and s in I with r+s=1
  int is_coprime_to(const Qideal& J, Quad& r, Quad& s) const;

  // return 1 iff this is coprime to alpha; if so, set inverse so an inverse of alpha modulo this
  int is_coprime_to(const Quad& alpha, Quad& inverse);

  // return J = (c/d)*this coprime to N, or (if anti=1) J such that J*this=(c) and d=1
  // (implemented in primes.cc)
  Qideal equivalent_coprime_to(const Qideal& N, Quad& c, Quad& d, int anti=0);

  //
  Qideal operator/(const long&) const;
  Qideal operator/(const Quad&) const;
  Qideal operator/(const Qideal&) const;
  friend Qideal operator/(const long&, const Qideal&);
  friend Qideal operator/(const Quad&, const Qideal&);
  void operator/=(const long&);
  void operator/=(const Quad&);
  void operator/=(const Qideal&);
//
//functions defined in qideal.cc unless inline
  int is_principal();          // fills iclass if necessary
  int is_principal(Quad& g);   // same but puts generator into g
  int is_square();
  int is_Galois_stable() {return ((*this)==this->conj());}

  int is_equivalent(Qideal& I)
  {
    return (I.conj()*(*this)).is_principal();
  }
  int is_anti_equivalent(Qideal& I)
  {
    return (I*(*this)).is_principal();
  }
  int contains(const long& n) const
  {
    return n%(ac)==0;
  }
  int contains(const Quad& alpha) const;
  int contains(const Qideal& I) const
  {
    return ((I.c)%c==0) && ((I.ac)%ac==0) && contains(I.zgen(1));
  };
  vector<long> zcoeffs(const Quad& alpha) const // for alpha in this, return Z-coeffs {x,y} w.r.t.Z-gens.
  {
    return {(alpha.r-b*alpha.i)/ac, alpha.i/c};
  }
  Quad zcombo(const long& x, const long& y) const
  {
    return Quad(x*ac+y*b*c, y*c);
  }
  int divides(const long& n) const {return contains(n);}
  int divides(const Quad& alpha) const  {return contains(alpha);}
  int divides(const Qideal& I) const  {return contains(I);}

  Qideal conj() const;            // returns the conjugate ideal

  Quad reduce(const Quad& alpha); // reduction of alpha modulo this ideal
  Quad resnum(int i); // the i'the residue mod this, in standard order (0'th is 0)
  int numres(const Quad& alpha); // the index of a residue mod this, in standard order (0'th is 0)
  // return a list of (reduced) residues modulo this ideal:
  vector<Quad> residues();
  // return a list of (reduced) invertible residues modulo this ideal, and a list of their inverses
  pair<vector<Quad>, vector<Quad>> invertible_residues();

// i/o
  friend ostream& operator<<(ostream& s, const Qideal& x);
  friend istream& operator>>(istream& s, Qideal& x);

  friend class Quadprime;

private:
  int ok() const;                 // checks that [a,b+w] *is* an ideal
  void fill();                    // determines iclass, g0, g1
  void abc_from_HNF(vector<long>&);
};

Qideal Qideal_from_norm_index(long N, int i); // i'th ideal of norm N

char* to_string(const Qideal& a);  // outputs to a (new) string

long val(const Qideal& factor, const Qideal& dividend);

// These three functions return lists which are not sorted in the standard way
vector<Qideal> primitive_ideals_with_norm(long N, int both_conj=1);
vector<Qideal> ideals_with_norm(long N, int both_conj=1);
vector<Qideal> ideals_with_bounded_norm(long maxnorm, int both_conj=1);

string ideal_label(Qideal& I);  // returns label of ideal I

// Class to hold sorted lists of ideals of given norm
class Qideal_lists {
  static map<long, vector<Qideal>> N_to_Ilist;
public:
  static vector<Qideal> ideals_with_norm(long N);
  static vector<Qideal> ideals_with_bounded_norm(long maxnorm);
};

#endif

// END OF FILE qideal.h
